<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris â€“ Vanilla JS (Single File)</title>
  <style>
    :root {
      --bg: #0f1220;
      --panel: #14182a;
      --accent: #7dd3fc;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --grid: #1f243d;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(1200px 800px at 20% 15%, #1a2042, var(--bg));
      color: var(--text);
      font: 500 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial;
      display: grid;
      place-items: center;
    }
    .wrap {
      display: grid;
      grid-template-columns: auto 260px;
      gap: 16px;
      padding: 20px;
      width: min(100%, 920px);
    }
    .board {
      background:
        linear-gradient(var(--grid) 1px, transparent 1px) 0 0/30px 30px,
        linear-gradient(90deg, var(--grid) 1px, transparent 1px) 0 0/30px 30px,
        #0b0f1f;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.5), inset 0 0 0 2px #11152b;
      position: relative;
    }
    canvas { display: block; border-radius: 16px; }

    .panel {
      background: linear-gradient(180deg, #101531, var(--panel));
      padding: 16px;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.45), inset 0 0 0 2px #11152b;
      display: grid;
      gap: 12px;
      align-content: start;
      position: relative;
    }
    h1 { font-size: 20px; margin: 0 0 8px; letter-spacing: .5px; }
    .stat { display: grid; grid-template-columns: 1fr auto; gap: 6px; align-items: center; }
    .label { color: var(--muted); font-size: 12px; letter-spacing: .3px; }
    .value { font-weight: 700; font-size: 18px; }
    .keys { font-size: 12px; color: var(--muted); line-height: 1.35; }
    kbd {
      padding: 2px 6px; border-radius: 6px; border: 1px solid #2a3156; background: #0c1230; color: #c7d2fe; font: 600 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      box-shadow: inset 0 -2px 0 rgba(0,0,0,.3);
    }

    .next, .hold, .mobile {
      background: #0b1026;
      border-radius: 12px;
      padding: 10px;
      border: 1px solid #20264b;
    }
    .mini { width: 120px; height: 120px; background: #060a1d; border-radius: 8px; display: grid; place-items: center; margin-inline: auto; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }

    .btn {
      appearance: none; border: 0; border-radius: 12px; padding: 10px 12px; font-weight: 700; cursor: pointer; background: linear-gradient(180deg, #1c244f, #12193a); color: #cfe9ff; border: 1px solid #24306b; box-shadow: 0 6px 20px rgba(0,0,0,.35), inset 0 0 0 2px #0d1330;
    }
    .btn:active { transform: translateY(1px); }

    .floating {
      position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none;
    }
    .modal {
      backdrop-filter: blur(3px);
      background: rgba(10,12,28,.55);
      border: 1px solid #20264b; color: var(--text); padding: 18px 20px; border-radius: 14px; text-align: center; pointer-events: auto; box-shadow: 0 20px 60px rgba(0,0,0,.6);
    }
    .title { font-size: 22px; font-weight: 800; margin: 0 0 6px; }
    .muted { color: var(--muted); font-size: 13px; }

    /* Touch controls */
    .touch {
      position: fixed; inset: auto 0 14px 0; display: none; place-items: center; gap: 12px; justify-content: center; pointer-events: none;
    }
    .touch .btn { pointer-events: auto; }
    @media (max-width: 900px) {
      .wrap { grid-template-columns: 1fr; gap: 12px; }
      .panel { order: -1; }
      .touch { display: grid; grid-auto-flow: column; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board">
      <canvas id="game" width="300" height="600" aria-label="Tetris board" role="img"></canvas>
      <div class="floating" id="overlay" hidden>
        <div class="modal">
          <p class="title" id="overlayTitle">Paused</p>
          <p class="muted" id="overlayHint">Press <kbd>P</kbd> to resume</p>
          <div style="margin-top:12px; display:flex; gap:8px; justify-content:center">
            <button class="btn" id="resumeBtn">Resume</button>
            <button class="btn" id="restartBtn">Restart</button>
          </div>
        </div>
      </div>
    </div>

    <aside class="panel">
      <h1>ðŸŽ® Tetris</h1>
      <div class="stat"><span class="label">Score</span><span class="value" id="score">0</span></div>
      <div class="stat"><span class="label">Level</span><span class="value" id="level">1</span></div>
      <div class="stat"><span class="label">Lines</span><span class="value" id="lines">0</span></div>
      <div class="next">
        <div class="label">Next</div>
        <div class="mini"><canvas id="next" width="120" height="120"></canvas></div>
      </div>
      <div class="hold">
        <div class="label">Hold <span class="muted">(C)</span></div>
        <div class="mini"><canvas id="hold" width="120" height="120"></canvas></div>
      </div>
      <div class="keys">
        <p><kbdâ†></kbd> <kbdâ†’</kbd> move, <kbd>â†“</kbd> soft drop</p>
        <p><kbd>â†‘</kbd>/<kbd>X</kbd> rotate CW, <kbd>Z</kbd> rotate CCW</p>
        <p><kbd>Space</kbd> hard drop, <kbd>C</kbd> hold, <kbd>P</kbd> pause</p>
        <p><kbd>R</kbd> restart</p>
      </div>
      <div class="row">
        <button class="btn" id="pauseBtn">Pause</button>
        <button class="btn" id="resetBtn">Reset</button>
      </div>
    </aside>
  </div>

  <!-- Touch controls for mobile -->
  <div class="touch">
    <button class="btn" data-act="left">â—€ï¸Ž</button>
    <button class="btn" data-act="rotate-ccw">âŸ²</button>
    <button class="btn" data-act="drop">âŸ‚</button>
    <button class="btn" data-act="rotate-cw">âŸ³</button>
    <button class="btn" data-act="right">â–¶ï¸Ž</button>
  </div>

  <script>
    // ====== Core config ======
    const COLS = 10, ROWS = 20, SIZE = 30; // 300x600 canvas
    const DROP_START = 900; // ms (level 1)
    const MIN_DROP = 70; // ms floor

    const COLORS = {
      I: '#67e8f9',
      J: '#60a5fa',
      L: '#fbbf24',
      O: '#facc15',
      S: '#34d399',
      T: '#c084fc',
      Z: '#f87171',
      G: '#1f2937' // ghost
    };

    // Tetromino definitions (matrices for 0Â° rotation)
    const SHAPES = {
      I: [
        [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0]
      ],
      J: [
        [1,0,0],
        [1,1,1],
        [0,0,0]
      ],
      L: [
        [0,0,1],
        [1,1,1],
        [0,0,0]
      ],
      O: [
        [1,1],
        [1,1]
      ],
      S: [
        [0,1,1],
        [1,1,0],
        [0,0,0]
      ],
      T: [
        [0,1,0],
        [1,1,1],
        [0,0,0]
      ],
      Z: [
        [1,1,0],
        [0,1,1],
        [0,0,0]
      ]
    };

    // ====== Canvas setup ======
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const nextCanvas = document.getElementById('next');
    const nctx = nextCanvas.getContext('2d');

    const holdCanvas = document.getElementById('hold');
    const hctx = holdCanvas.getContext('2d');

    // ====== Game state ======
    let board, piece, bag = [], nextQueue = [], hold = null, canHold = true;
    let score = 0, lines = 0, level = 1;
    let dropInterval = DROP_START;
    let lastTime = 0, acc = 0, running = true, gameOver = false;

    // ====== Utilities ======
    const rnd = (n) => Math.floor(Math.random()*n);

    function createMatrix(w, h, fill = 0) {
      return Array.from({length: h}, () => Array(w).fill(fill));
    }

    function cloneMatrix(m) { return m.map(r => r.slice()); }

    function rotate(mat, dir=1) {
      // Transpose + reverse rows (dir=1 CW, -1 CCW)
      const N = mat.length;
      const res = createMatrix(N, N);
      for (let y=0; y<N; y++)
        for (let x=0; x<N; x++)
          res[x][dir>0? N-1-y : y] = mat[y][x];
      if (dir<0) {
        // CCW: transpose then reverse columns
        // Already handled in mapping
      }
      return res;
    }

    function bag7() {
      const keys = Object.keys(SHAPES);
      const pool = keys.slice();
      const out = [];
      while (pool.length) out.push(pool.splice(rnd(pool.length),1)[0]);
      return out;
    }

    function refillQueue() {
      if (bag.length === 0) bag = bag7();
      while (nextQueue.length < 5) {
        if (bag.length === 0) bag = bag7();
        nextQueue.push(bag.shift());
      }
    }

    function spawnPiece() {
      const type = nextQueue.shift();
      refillQueue();
      const mat = cloneMatrix(SHAPES[type]);
      const p = {
        type,
        mat,
        x: Math.floor((COLS - mat[0].length) / 2),
        y: -getTopOffset(mat),
        rot: 0
      };
      if (collide(board, p)) {
        // Game Over
        running = false; gameOver = true; showOverlay('Game Over', 'Press R to restart');
      }
      return p;
    }

    function getTopOffset(mat){
      for (let y=0; y<mat.length; y++) {
        if (mat[y].some(v=>v)) return y; // first non-empty row
      }
      return 0;
    }

    function collide(brd, p) {
      for (let y=0; y<p.mat.length; y++) {
        for (let x=0; x<p.mat[y].length; x++) {
          if (!p.mat[y][x]) continue;
          const by = p.y + y;
          const bx = p.x + x;
          if (by < 0) continue; // allow spawn above board
          if (bx < 0 || bx >= COLS || by >= ROWS) return true;
          if (brd[by][bx]) return true;
        }
      }
      return false;
    }

    function merge(brd, p) {
      for (let y=0; y<p.mat.length; y++)
        for (let x=0; x<p.mat[y].length; x++)
          if (p.mat[y][x]) brd[p.y + y][p.x + x] = p.type;
    }

    function clearLines() {
      let cleared = 0;
      outer: for (let y=ROWS-1; y>=0; y--) {
        for (let x=0; x<COLS; x++) if (!board[y][x]) continue outer;
        board.splice(y,1);
        board.unshift(Array(COLS).fill(0));
        cleared++; y++;
      }
      if (cleared) {
        const points = [0,100,300,500,800][cleared] * level;
        score += points; lines += cleared;
        if (lines >= level * 10) levelUp();
        updateHUD();
      }
    }

    function levelUp(){
      level++;
      dropInterval = Math.max(MIN_DROP, Math.floor(DROP_START * Math.pow(0.85, level-1)));
    }

    function softDrop(){
      piece.y++;
      if (collide(board, piece)) { piece.y--; lockPiece(); return false; }
      score++; updateHUD(); return true;
    }

    function hardDrop(){
      let dist = 0;
      while (!collide(board, {...piece, y: piece.y+1})) { piece.y++; dist++; }
      score += 2*dist; lockPiece(); updateHUD();
    }

    function tryRotate(dir){
      const old = piece.mat;
      const rotated = rotate(old, dir);
      const oldX = piece.x;
      const kicks = [0, -1, 1, -2, 2];
      for (const k of kicks){
        const test = { ...piece, mat: rotated, x: oldX + k };
        if (!collide(board, test)) { piece.mat = rotated; piece.x = test.x; return; }
      }
      // if failed, do nothing
    }

    function lockPiece(){
      merge(board, piece);
      clearLines();
      piece = spawnPiece();
      canHold = true;
    }

    function holdPiece(){
      if (!canHold) return;
      const cur = piece.type;
      if (hold == null) {
        hold = cur;
        piece = spawnPiece();
      } else {
        const tmp = hold; hold = cur;
        piece = makePiece(tmp);
      }
      canHold = false; drawHold();
    }

    function makePiece(type) {
      const mat = cloneMatrix(SHAPES[type]);
      return {
        type,
        mat,
        x: Math.floor((COLS - mat[0].length) / 2),
        y: -getTopOffset(mat),
        rot: 0
      };
    }

    // ====== Rendering ======
    function drawBlock(context, x, y, color) {
      context.fillStyle = color;
      context.fillRect(x*SIZE, y*SIZE, SIZE, SIZE);
      context.fillStyle = 'rgba(255,255,255,0.08)';
      context.fillRect(x*SIZE, y*SIZE, SIZE, 6); // simple highlight
      context.strokeStyle = 'rgba(0,0,0,0.35)';
      context.strokeRect(x*SIZE+0.5, y*SIZE+0.5, SIZE-1, SIZE-1);
    }

    function getGhostY(){
      let y = piece.y;
      while (!collide(board, {...piece, y: y+1})) y++;
      return y;
    }

    function draw() {
      // Clear board area
      ctx.clearRect(0,0,canvas.width, canvas.height);

      // Draw placed blocks
      for (let y=0; y<ROWS; y++){
        for (let x=0; x<COLS; x++){
          const cell = board[y][x];
          if (cell) drawBlock(ctx, x, y, COLORS[cell]);
        }
      }

      // Draw ghost
      const gy = getGhostY();
      for (let y=0; y<piece.mat.length; y++)
        for (let x=0; x<piece.mat[y].length; x++)
          if (piece.mat[y][x]) drawBlock(ctx, piece.x + x, gy + y, 'rgba(255,255,255,0.06)');

      // Draw current piece
      for (let y=0; y<piece.mat.length; y++)
        for (let x=0; x<piece.mat[y].length; x++)
          if (piece.mat[y][x]) drawBlock(ctx, piece.x + x, piece.y + y, COLORS[piece.type]);
    }

    function drawMini(ctx2, type) {
      ctx2.clearRect(0,0,120,120);
      if (!type) return;
      const mat = SHAPES[type];
      const s = 22; // mini block size
      // center
      const w = mat[0].length * s;
      const h = mat.length * s;
      const ox = Math.floor((120 - w) / 2);
      const oy = Math.floor((120 - h) / 2);
      for (let y=0; y<mat.length; y++)
        for (let x=0; x<mat[y].length; x++)
          if (mat[y][x]) {
            ctx2.fillStyle = COLORS[type];
            ctx2.fillRect(ox + x*s, oy + y*s, s, s);
            ctx2.fillStyle = 'rgba(255,255,255,0.12)';
            ctx2.fillRect(ox + x*s, oy + y*s, s, 4);
            ctx2.strokeStyle = 'rgba(0,0,0,0.35)';
            ctx2.strokeRect(ox + x*s + .5, oy + y*s + .5, s-1, s-1);
          }
    }

    function drawNext(){ drawMini(nctx, nextQueue[0]); }
    function drawHold(){ drawMini(hctx, hold); }

    function updateHUD(){
      document.getElementById('score').textContent = score;
      document.getElementById('level').textContent = level;
      document.getElementById('lines').textContent = lines;
      drawNext();
    }

    // ====== Game Loop ======
    function loop(time=0){
      if (!running) return; // pause/game over stops RAF
      const dt = time - lastTime; lastTime = time; acc += dt;
      while (acc >= dropInterval) { if (!softDrop()) break; acc -= dropInterval; }
      draw();
      requestAnimationFrame(loop);
    }

    // ====== Input ======
    const keys = new Set();
    document.addEventListener('keydown', (e) => {
      if (gameOver && e.key.toLowerCase() !== 'r') return;
      switch (e.key) {
        case 'ArrowLeft': move(-1); break;
        case 'ArrowRight': move(1); break;
        case 'ArrowDown': softDrop(); break;
        case 'ArrowUp':
        case 'x':
        case 'X': tryRotate(1); break;
        case 'z':
        case 'Z': tryRotate(-1); break;
        case ' ': e.preventDefault(); hardDrop(); break;
        case 'c':
        case 'C': holdPiece(); break;
        case 'p':
        case 'P': togglePause(); break;
        case 'r':
        case 'R': restart(); break;
      }
    });

    function move(dir){
      piece.x += dir;
      if (collide(board, piece)) piece.x -= dir;
    }

    // Touch buttons
    document.querySelectorAll('.touch .btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const a = btn.dataset.act;
        if (a==='left') move(-1);
        if (a==='right') move(1);
        if (a==='rotate-cw') tryRotate(1);
        if (a==='rotate-ccw') tryRotate(-1);
        if (a==='drop') hardDrop();
      });
    });

    // Buttons & overlay
    document.getElementById('pauseBtn').onclick = togglePause;
    document.getElementById('resetBtn').onclick = restart;
    document.getElementById('resumeBtn').onclick = () => { if (!gameOver) togglePause(false); };
    document.getElementById('restartBtn').onclick = restart;

    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayHint = document.getElementById('overlayHint');

    function showOverlay(title, hint){
      overlayTitle.textContent = title; overlayHint.innerHTML = hint; overlay.hidden = false;
    }
    function hideOverlay(){ overlay.hidden = true; }

    function togglePause(force){
      if (gameOver) return;
      const to = typeof force === 'boolean' ? force : !running;
      if (to) { // want running = true
        if (!running) {
          running = true; lastTime = performance.now(); requestAnimationFrame(loop); hideOverlay();
        }
      } else {
        running = false; showOverlay('Paused', 'Press <kbd>P</kbd> to resume');
      }
    }

    function restart(){
      board = createMatrix(COLS, ROWS, 0);
      score = 0; lines = 0; level = 1; dropInterval = DROP_START; acc = 0; lastTime = 0;
      bag = []; nextQueue = []; hold = null; canHold = true; gameOver = false;
      refillQueue();
      piece = spawnPiece();
      updateHUD(); drawHold(); hideOverlay();
      if (!running) { running = true; }
      lastTime = performance.now(); requestAnimationFrame(loop);
    }

    // ====== Boot ======
    restart();
  </script>
</body>
</html>
