<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¾·å·æ‰‘å…‹ (ç«–å±æ²‰æµ¸ç‰ˆ)</title>
    <style>
        :root {
            --felt-color: #35654d;
            --highlight-color: #ffd700;
            --card-w: 46px;
            --card-h: 64px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1a1a1a;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            width: 100%;
            max-width: 800px;
            position: relative;
            margin-bottom: 15px;
            margin-top: 10px;
        }
        
        /* === æ¡Œé¢ç«¯é»˜è®¤æ ·å¼ (æ¨ªå‘) === */
        #game-table {
            position: relative;
            width: 100%;
            padding-bottom: 60%; /* æ¡Œé¢ç«¯ä¿æŒæ‰å¹³æ¤­åœ† */
            background-color: var(--felt-color);
            border: 10px solid #5d4037;
            border-radius: 300px;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.6), 0 10px 20px rgba(0,0,0,0.5);
            margin: 0 auto;
        }

        #community-cards {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 4px;
            z-index: 5;
            width: 100%;
            justify-content: center;
        }

        #pot-display {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1em;
            background: rgba(0,0,0,0.4);
            padding: 4px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.3);
            z-index: 5;
            white-space: nowrap;
        }

        .player {
            position: absolute;
            width: var(--card-w);
            min-width: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        .player-info {
            background: rgba(0,0,0,0.7);
            padding: 2px 5px;
            border-radius: 4px;
            text-align: center;
            font-size: 11px;
            width: 130%;
            margin-bottom: 3px;
            white-space: nowrap;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            transition: all 0.3s;
        }

        .player-cards {
            display: flex;
            justify-content: center;
            gap: 1px;
        }

        /* === æ¡Œé¢ç«¯åæ ‡ === */
        #p0 { bottom: -12%; left: 50%; transform: translateX(-50%); }
        #p1 { bottom: 15%; left: -5%; }
        #p2 { top: 25%; left: -5%; }
        #p3 { top: -10%; left: 25%; }
        #p4 { top: -10%; right: 25%; }
        #p5 { top: 25%; right: -5%; }
        #p6 { bottom: 15%; right: -5%; }

        .card {
            width: var(--card-w);
            height: var(--card-h);
            background: white;
            border-radius: 4px;
            color: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            line-height: 1;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            position: relative;
            transition: box-shadow 0.3s;
        }
        .card.red { color: #d00; }
        .card.back {
            background: repeating-linear-gradient(45deg, #606dbc, #606dbc 5px, #465298 5px, #465298 10px);
            border: 2px solid #fff;
        }
        
        .card.winning-card {
            border: 2px solid #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 1);
            z-index: 100;
        }

        .winner-highlight .player-info { 
            border: 1px solid var(--highlight-color); 
            background: rgba(255, 215, 0, 0.4); 
            color: #fff;
            box-shadow: 0 0 10px gold;
        }
        .active-turn .player-info {
            background: #e65100;
            box-shadow: 0 0 10px #ff9800;
            transform: scale(1.1);
            z-index: 50;
        }
        .folded { opacity: 0.4; filter: grayscale(100%); }

        .dealer-btn {
            background: white; color: black; border-radius: 50%;
            width: 18px; height: 18px; font-size: 11px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            position: absolute; top: -8px; right: -8px; z-index: 30;
            display: none; box-shadow: 0 0 3px black; border: 1px solid #333;
        }

        #controls {
            margin-top: 30px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
            width: 100%;
            max-width: 600px;
            z-index: 50;
            padding: 0 10px;
        }
        button {
            padding: 14px 0;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            touch-action: manipulation;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        button:active { transform: translateY(3px); box-shadow: none; }
        .btn-fold { background: #c62828; color: white; }
        .btn-check { background: #1565c0; color: white; }
        .btn-raise { background: #2e7d32; color: white; }
        .btn-next { background: #ef6c00; color: white; grid-column: span 3; display: none; margin-top: 5px; animation: popIn 0.3s ease; }
        button:disabled { background: #444; color: #888; box-shadow: none; transform: none; }

        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        #log-area {
            width: 100%; max-width: 800px; height: 100px;
            background: #222; margin-top: 15px;
            overflow-y: auto; padding: 8px;
            font-family: monospace; font-size: 12px;
            border: 1px solid #444; color: #ccc;
            border-radius: 6px;
        }

        #hand-ranks-bar {
            width: 100%; max-width: 800px;
            display: flex; flex-wrap: wrap; 
            justify-content: center; gap: 4px;
            margin-top: 10px; padding: 5px 0;
        }
        .rank-item {
            font-size: 11px; color: #666; 
            padding: 4px 8px; border-radius: 4px;
            background: #111;
        }
        .rank-active {
            color: #000; background-color: var(--highlight-color);
            font-weight: bold;
        }

        /* === ğŸ“± ç§»åŠ¨ç«¯ ç«–å± æ·±åº¦é€‚é… === */
        @media (max-width: 600px) {
            :root {
                /* ç¨å¾®å‡å°å¡ç‰Œå°ºå¯¸ï¼Œè®©ç”»é¢ä¸æ‹¥æŒ¤ */
                --card-w: 12vw; 
                --card-h: 16.5vw;
            }

            #game-container {
                /* é¡¶éƒ¨ç•™å‡ºæ›´å¤šç©ºé—´ï¼Œé˜²æ­¢P3/P4è´´è¾¹ */
                margin-top: 20px;
            }

            #game-table {
                /* å…³é”®ä¿®æ”¹ï¼šå¢åŠ é«˜åº¦æ¯”ä¾‹ï¼Œå……åˆ†åˆ©ç”¨ç«–å±ç©ºé—´ */
                /* 135% æ„å‘³ç€é«˜åº¦æ˜¯å®½åº¦çš„ 1.35å€ï¼Œå½¢æˆç˜¦é•¿æ¤­åœ† */
                padding-bottom: 135%; 
                border-radius: 50%; /* å˜æˆæ­£æ¤­åœ† */
                border-width: 6px;
            }

            /* === ç©å®¶åæ ‡é‡æ’ (é’ˆå¯¹é•¿æ¡Œ) === */
            
            /* é¡¶éƒ¨ç©å®¶ (P3, P4) å¾€é‡Œæ”¶ä¸€ç‚¹ï¼Œåˆ«å¤ªé«˜ */
            #p3 { top: -4%; left: 20%; }
            #p4 { top: -4%; right: 20%; }

            /* å·¦ä¾§ç©å®¶ (P1, P2) å‡åŒ€åˆ†å¸ƒ */
            #p2 { top: 20%; left: -6%; }   /* ä¸Šæ–¹ä¾§è¾¹ */
            #p1 { top: auto; bottom: 25%; left: -6%; } /* ä¸‹æ–¹ä¾§è¾¹ */

            /* å³ä¾§ç©å®¶ (P5, P6) å‡åŒ€åˆ†å¸ƒ */
            #p5 { top: 20%; right: -6%; }  /* ä¸Šæ–¹ä¾§è¾¹ */
            #p6 { top: auto; bottom: 25%; right: -6%; } /* ä¸‹æ–¹ä¾§è¾¹ */

            /* è‡ªå·± (P0) */
            #p0 { bottom: -6%; }

            /* å…¬å…±ç‰Œä½ç½®å¾®è°ƒ */
            #community-cards { top: 48%; gap: 2px; }
            #pot-display { top: 35%; font-size: 0.9em; }

            .card { font-size: 14px; border-radius: 3px; }
            .player-info { font-size: 10px; width: 110%; padding: 2px; }
            
            #controls { margin-top: 35px; gap: 8px; }
            button { font-size: 15px; padding: 12px 0; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="game-table">
            <div id="pot-display">Pot: 0</div>
            <div id="community-cards"></div>
            
            <div id="p0" class="player"><div class="player-info"><div>ä½ </div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
            <div id="p1" class="player"><div class="player-info"><div>P1</div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
            <div id="p2" class="player"><div class="player-info"><div>P2</div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
            <div id="p3" class="player"><div class="player-info"><div>P3</div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
            <div id="p4" class="player"><div class="player-info"><div>P4</div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
            <div id="p5" class="player"><div class="player-info"><div>P5</div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
            <div id="p6" class="player"><div class="player-info"><div>P6</div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
        </div>
    </div>

    <div id="controls">
        <button id="btn-fold" class="btn-fold" onclick="game.humanAction('fold')">å¼ƒç‰Œ</button>
        <button id="btn-call" class="btn-check" onclick="game.humanAction('call')">è·Ÿæ³¨/è¿‡ç‰Œ</button>
        <button id="btn-raise" class="btn-raise" onclick="game.humanAction('raise')">åŠ æ³¨ (10)</button>
        <button id="btn-next" class="btn-next" onclick="game.startNextRound()">ä¸‹ä¸€å±€</button>
    </div>

    <div id="hand-ranks-bar">
        <div id="rank-0" class="rank-item">é«˜ç‰Œ</div>
        <div id="rank-1" class="rank-item">ä¸€å¯¹</div>
        <div id="rank-2" class="rank-item">ä¸¤å¯¹</div>
        <div id="rank-3" class="rank-item">ä¸‰æ¡</div>
        <div id="rank-4" class="rank-item">é¡ºå­</div>
        <div id="rank-5" class="rank-item">åŒèŠ±</div>
        <div id="rank-6" class="rank-item">è‘«èŠ¦</div>
        <div id="rank-7" class="rank-item">å››æ¡</div>
        <div id="rank-8" class="rank-item">åŒèŠ±é¡º</div>
    </div>

    <div id="log-area"></div>

<script>
// === é€»è¾‘ä»£ç  (Evaluate & Game Logic) ä¿æŒå®Œå…¨ä¸€è‡´ ===

const SUITS = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
const RANK_VALUE = {'2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, 'T':10, 'J':11, 'Q':12, 'K':13, 'A':14};

class Card {
    constructor(rank, suit) {
        this.rank = rank;
        this.suit = suit;
        this.value = RANK_VALUE[rank];
    }
    get color() { return (this.suit === 'â™¥' || this.suit === 'â™¦') ? 'red' : 'black'; }
}

class Deck {
    constructor() { this.cards = []; this.reset(); }
    reset() {
        this.cards = [];
        for (let s of SUITS) for (let r of RANKS) this.cards.push(new Card(r, s));
        this.shuffle();
    }
    shuffle() {
        for (let i = this.cards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
        }
    }
    deal() { return this.cards.pop(); }
}

const HandRank = {
    HIGH_CARD: 0, PAIR: 1, TWO_PAIR: 2, TRIPS: 3, STRAIGHT: 4, 
    FLUSH: 5, FULL_HOUSE: 6, QUADS: 7, STRAIGHT_FLUSH: 8
};

function evaluateHand(cards) {
    let sorted = [...cards].sort((a,b) => b.value - a.value);
    
    let suitCounts = {}, rankCounts = {};
    sorted.forEach(c => {
        suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1;
        rankCounts[c.value] = (rankCounts[c.value] || 0) + 1;
    });

    let flushSuit = Object.keys(suitCounts).find(s => suitCounts[s] >= 5);
    let flushCards = flushSuit ? sorted.filter(c => c.suit === flushSuit) : [];

    const getStraight = (cardList) => {
        let unique = [];
        cardList.forEach(c => { if(!unique.find(u => u.value === c.value)) unique.push(c); });
        if (unique.some(c => c.value === 14)) {
            let aceLow = new Card('A', unique.find(c=>c.value===14).suit);
            aceLow.value = 1;
            unique.push(aceLow);
        }
        for(let i=0; i<=unique.length-5; i++) {
            if(unique[i].value - unique[i+4].value === 4) return unique.slice(i, i+5);
        }
        return null;
    };

    let straightCards = getStraight(sorted);
    let straightFlushCards = flushSuit ? getStraight(flushCards) : null;

    if (straightFlushCards) return { rank: HandRank.STRAIGHT_FLUSH, score: straightFlushCards[0].value, winningCards: straightFlushCards };
    let quadsVal = Object.keys(rankCounts).find(r => rankCounts[r] === 4);
    if (quadsVal) {
        quadsVal = parseInt(quadsVal);
        let quads = sorted.filter(c => c.value === quadsVal);
        return { rank: HandRank.QUADS, score: quadsVal, winningCards: quads };
    }
    let tripsVals = Object.keys(rankCounts).filter(r => rankCounts[r] === 3).map(Number).sort((a,b)=>b-a);
    let pairVals = Object.keys(rankCounts).filter(r => rankCounts[r] === 2).map(Number).sort((a,b)=>b-a);
    if (tripsVals.length > 0) {
        let tVal = tripsVals[0];
        let pVal = -1;
        if (tripsVals.length > 1) pVal = tripsVals[1];
        else if (pairVals.length > 0) pVal = pairVals[0];
        if (pVal !== -1) {
            let tCards = sorted.filter(c => c.value === tVal);
            let pCards = sorted.filter(c => c.value === pVal).slice(0, 2);
            return { rank: HandRank.FULL_HOUSE, score: tVal * 100 + pVal, winningCards: [...tCards, ...pCards] };
        }
    }
    if (flushCards.length >= 5) return { rank: HandRank.FLUSH, score: flushCards[0].value, winningCards: flushCards.slice(0, 5) };
    if (straightCards) return { rank: HandRank.STRAIGHT, score: straightCards[0].value, winningCards: straightCards };
    if (tripsVals.length > 0) {
        let tVal = tripsVals[0];
        let trips = sorted.filter(c => c.value === tVal);
        return { rank: HandRank.TRIPS, score: tVal, winningCards: trips };
    }
    if (pairVals.length >= 2) {
        let p1 = pairVals[0], p2 = pairVals[1];
        let pair1 = sorted.filter(c => c.value === p1);
        let pair2 = sorted.filter(c => c.value === p2);
        return { rank: HandRank.TWO_PAIR, score: p1*100 + p2, winningCards: [...pair1, ...pair2] };
    }
    if (pairVals.length === 1) {
        let p1 = pairVals[0];
        let pair = sorted.filter(c => c.value === p1);
        return { rank: HandRank.PAIR, score: p1, winningCards: pair };
    }
    return { rank: HandRank.HIGH_CARD, score: sorted[0].value, winningCards: [sorted[0]] };
}

class PokerGame {
    constructor() {
        this.players = [];
        for(let i=0; i<7; i++) {
            this.players.push({
                id: i, isHuman: i === 0, chips: 100, hand: [], 
                status: 'active', currentBet: 0, isEliminated: false
            });
        }
        this.deck = new Deck();
        this.communityCards = [];
        this.pot = 0;
        this.dealerIdx = Math.floor(Math.random() * 7);
        this.highestBet = 0;
        this.stage = 'preflop';
        this.logElem = document.getElementById('log-area');
        this.actorsLeft = 0; 
        this.raisesInRound = 0;
        
        this.disableControls(true);
        this.startNextRound();
    }

    log(msg) {
        let div = document.createElement('div');
        div.textContent = msg;
        this.logElem.prepend(div);
    }

    startNextRound() {
        let activePlayers = this.players.filter(p => !p.isEliminated);
        if (activePlayers.length <= 1) {
            alert(`æ¸¸æˆç»“æŸ! è·èƒœè€…: P${activePlayers[0].id}`);
            return;
        }

        document.querySelectorAll('.rank-item').forEach(el => el.classList.remove('rank-active'));
        document.querySelectorAll('.player').forEach(el => el.classList.remove('winner-highlight'));
        document.querySelectorAll('.card').forEach(el => el.classList.remove('winning-card')); 
        document.getElementById('btn-next').style.display = 'none';
        
        this.deck.reset();
        this.communityCards = [];
        this.pot = 0;
        this.stage = 'preflop';
        this.players.forEach(p => {
            if(!p.isEliminated) {
                p.hand = [this.deck.deal(), this.deck.deal()];
                p.status = 'active';
                p.currentBet = 0;
            } else {
                p.status = 'eliminated';
                p.hand = [];
            }
        });

        do { this.dealerIdx = (this.dealerIdx + 1) % 7; } 
        while (this.players[this.dealerIdx].isEliminated);

        let sbIdx = this.getNextActive(this.dealerIdx);
        let bbIdx = this.getNextActive(sbIdx);
        
        this.bet(sbIdx, 5);
        this.bet(bbIdx, 10);
        this.highestBet = 10;
        
        this.log(`--- æ–°å›åˆ (D: P${this.dealerIdx}) ---`);
        this.updateUI();
        this.prepareBettingRound(this.getNextActive(bbIdx)); 
    }

    prepareBettingRound(startIdx) {
        this.raisesInRound = 0;
        let activeCount = this.players.filter(p => p.status !== 'eliminated' && p.status !== 'folded').length;
        if(activeCount < 2) { this.showdown(); return; }
        this.actorsLeft = activeCount;
        this.currentTurnIdx = startIdx;
        this.processTurn();
    }

    getNextActive(idx) {
        let next = (idx + 1) % 7;
        while(this.players[next].isEliminated || this.players[next].status === 'folded') {
            next = (next + 1) % 7;
        }
        return next;
    }

    bet(playerIdx, amount) {
        let p = this.players[playerIdx];
        if (amount > p.chips) amount = p.chips;
        p.chips -= amount;
        p.currentBet += amount;
        this.pot += amount;
        if (p.currentBet > this.highestBet) this.highestBet = p.currentBet;
        if (p.chips === 0 && p.status !== 'folded') p.status = 'allin';
    }

    async processTurn() {
        let active = this.players.filter(p => p.status !== 'eliminated' && p.status !== 'folded');
        let notAllIn = active.filter(p => p.status !== 'allin');
        
        if (active.length === 1 || (notAllIn.length === 0 && this.isBetsSettled())) {
            this.runRemainingStages();
            return;
        }

        if (this.actorsLeft <= 0 && this.isBetsSettled()) {
            this.nextStage();
            return;
        }

        let p = this.players[this.currentTurnIdx];
        if (p.status === 'allin') {
            this.currentTurnIdx = this.getNextActive(this.currentTurnIdx);
            this.processTurn(); 
            return;
        }

        document.querySelectorAll('.player').forEach(el => el.classList.remove('active-turn'));
        document.getElementById(`p${p.id}`).classList.add('active-turn');
        
        this.logElem.scrollTop = 0;

        if (p.isHuman) {
            this.log(">>> è½®åˆ°ä½ äº†");
            this.updateControls();
        } else {
            this.disableControls(true);
            setTimeout(() => this.aiAction(p), 600);
        }
    }

    isBetsSettled() {
        let active = this.players.filter(p => p.status !== 'eliminated' && p.status !== 'folded' && p.status !== 'allin');
        if (active.length === 0) return true;
        let target = this.highestBet;
        return active.every(p => p.currentBet === target);
    }

    nextStage() {
        this.players.forEach(p => p.currentBet = 0);
        this.highestBet = 0;
        
        if (this.stage === 'preflop') {
            this.stage = 'flop';
            this.communityCards.push(this.deck.deal(), this.deck.deal(), this.deck.deal());
            this.log(`--- ç¿»ç‰Œ ---`);
        } else if (this.stage === 'flop') {
            this.stage = 'turn';
            this.communityCards.push(this.deck.deal());
            this.log(`--- è½¬ç‰Œ ---`);
        } else if (this.stage === 'turn') {
            this.stage = 'river';
            this.communityCards.push(this.deck.deal());
            this.log(`--- æ²³ç‰Œ ---`);
        } else if (this.stage === 'river') {
            this.showdown();
            return;
        }

        this.updateUI();
        let startIdx = this.getNextActive(this.dealerIdx);
        this.prepareBettingRound(startIdx);
    }

    runRemainingStages() {
        while(this.stage !== 'showdown') {
             if (this.stage === 'river') { this.showdown(); return; }
             this.nextStage();
        }
    }

    showdown() {
        this.stage = 'showdown';
        document.querySelectorAll('.player').forEach(el => el.classList.remove('active-turn'));
        this.updateUI(); 

        let active = this.players.filter(p => p.status !== 'folded' && p.status !== 'eliminated');
        let bestPlayer = null;
        let bestScore = -1;
        let bestRes = null;

        this.log("--- æ‘Šç‰Œæ—¶åˆ» ---");

        active.forEach(p => {
            let fullHand = [...p.hand, ...this.communityCards];
            let res = evaluateHand(fullHand);
            let score = res.rank * 1000000 + res.score; 
            
            this.renderCards(p.id, p.hand, true);
            this.log(`P${p.id}: ${this.getRankName(res.rank)}`);

            if (score > bestScore) {
                bestScore = score;
                bestPlayer = p;
                bestRes = res;
            }
        });

        if (bestPlayer && bestRes) {
            this.log(`ğŸ‰ P${bestPlayer.id} è·èƒœ! èµ¢å¾— $${this.pot}`);
            bestPlayer.chips += this.pot;
            
            document.getElementById(`p${bestPlayer.id}`).classList.add('winner-highlight');
            let rankEl = document.getElementById(`rank-${bestRes.rank}`);
            if(rankEl) rankEl.classList.add('rank-active');
            this.highlightWinningCards(bestPlayer.id, bestRes.winningCards);
        }

        this.players.forEach(p => {
            if (p.chips <= 0) {
                p.chips = 0; p.isEliminated = true; p.status = 'eliminated';
            }
        });

        this.pot = 0;
        document.getElementById('pot-display').textContent = `Pot: 0`;
        this.players.forEach(p => document.querySelector(`#p${p.id} .chips`).textContent = p.chips);
        
        document.getElementById('btn-next').style.display = 'block';
        this.disableControls(true);
    }

    highlightWinningCards(winnerId, winningCards) {
        const isWinner = (c) => winningCards.some(wc => wc.suit === c.suit && wc.rank === c.rank);
        let p = this.players[winnerId];
        let pCardsHtml = p.hand.map(c => this.createCardHtml(c, isWinner(c))).join('');
        document.querySelector(`#p${winnerId} .player-cards`).innerHTML = pCardsHtml;
        let commHtml = this.communityCards.map(c => this.createCardHtml(c, isWinner(c))).join('');
        document.getElementById('community-cards').innerHTML = commHtml;
    }
    
    getRankName(idx) {
        const names = ["é«˜ç‰Œ", "ä¸€å¯¹", "ä¸¤å¯¹", "ä¸‰æ¡", "é¡ºå­", "åŒèŠ±", "è‘«èŠ¦", "å››æ¡", "åŒèŠ±é¡º"];
        return names[idx];
    }

    handleAction(player, action, amount=0) {
        let callAmt = this.highestBet - player.currentBet;
        if (action === 'fold') {
            player.status = 'folded';
            this.log(`P${player.id} å¼ƒç‰Œ`);
        } else if (action === 'call') {
            this.bet(player.id, callAmt);
            let msg = (callAmt === 0) ? "è¿‡ç‰Œ" : "è·Ÿæ³¨";
            this.log(`P${player.id} ${msg}`);
        } else if (action === 'raise') {
            let raiseAmt = callAmt + amount;
            this.bet(player.id, raiseAmt);
            this.log(`P${player.id} åŠ æ³¨ ${amount}`);
            this.raisesInRound++;
            let activeNotAllIn = this.players.filter(p => 
                p.status !== 'folded' && p.status !== 'eliminated' && p.status !== 'allin'
            ).length;
            this.actorsLeft = activeNotAllIn; 
        }
        this.actorsLeft--;
        this.updateUI();
        this.currentTurnIdx = this.getNextActive(this.currentTurnIdx);
        this.processTurn();
    }

    humanAction(type) {
        let p = this.players[0];
        if (type === 'raise') this.handleAction(p, 'raise', 10);
        else this.handleAction(p, type);
    }

    aiAction(player) {
        let callAmt = this.highestBet - player.currentBet;
        let fullHand = [...player.hand, ...this.communityCards];
        let action = 'fold';
        let strength = 0; 
        if (fullHand.length < 5) {
            let v1 = player.hand[0].value, v2 = player.hand[1].value;
            if (v1 === v2) strength = 2;
            else if (v1 > 10 && v2 > 10) strength = 1.5;
            else if (v1 > 12 || v2 > 12) strength = 1;
        } else {
            let res = evaluateHand(fullHand);
            strength = res.rank + (res.score / 1000000); 
        }
        let canRaise = (this.raisesInRound < 4); 
        if (strength >= 2) { 
            if (canRaise && Math.random() > 0.4) action = 'raise'; else action = 'call';
        } else if (strength >= 1) { 
            if (callAmt < 20) action = 'call'; else action = Math.random() > 0.6 ? 'call' : 'fold';
        } else { 
            if (callAmt === 0) action = 'call'; else action = Math.random() > 0.85 ? 'raise' : 'fold';
        }
        if (action === 'raise') this.handleAction(player, 'raise', 10);
        else this.handleAction(player, action);
    }

    updateUI() {
        document.getElementById('pot-display').textContent = `Pot: ${this.pot}`;
        document.getElementById('community-cards').innerHTML = this.communityCards.map(c => this.createCardHtml(c)).join('');

        this.players.forEach(p => {
            let el = document.getElementById(`p${p.id}`);
            el.querySelector('.chips').textContent = p.chips;
            
            let statusText = '';
            if (p.status === 'folded') statusText = 'Fold';
            else if (p.status === 'eliminated') statusText = 'Out';
            else if (p.status === 'allin') statusText = 'All-in';
            else if (p.currentBet > 0) statusText = `$${p.currentBet}`;
            
            el.querySelector('.status').textContent = statusText;
            el.querySelector('.dealer-btn').style.display = (this.dealerIdx === p.id) ? 'flex' : 'none';

            if (p.hand.length > 0) {
                let showFace = (p.isHuman || this.stage === 'showdown');
                this.renderCards(p.id, p.hand, showFace);
            } else {
                el.querySelector('.player-cards').innerHTML = '';
            }
            
            if (p.status === 'folded') el.querySelector('.player-cards').classList.add('folded');
            else el.querySelector('.player-cards').classList.remove('folded');
            if (p.isEliminated) el.style.opacity = 0.3;
        });
    }

    renderCards(pid, cards, showFace) {
        let html = '';
        if (showFace) html = cards.map(c => this.createCardHtml(c)).join('');
        else html = `<div class="card back"></div><div class="card back"></div>`;
        document.getElementById(`p${pid}`).querySelector('.player-cards').innerHTML = html;
    }

    createCardHtml(card, isHighlighted = false) {
        let cls = `card ${card.color} ${isHighlighted ? 'winning-card' : ''}`;
        return `<div class="${cls}">${card.suit}<br>${card.rank}</div>`;
    }

    updateControls() {
        let p = this.players[0];
        let callAmt = this.highestBet - p.currentBet;
        document.getElementById('btn-fold').disabled = false;
        document.getElementById('btn-call').disabled = false;
        document.getElementById('btn-raise').disabled = (p.chips <= callAmt) || (this.raisesInRound >= 4);
        document.getElementById('btn-call').textContent = (callAmt === 0) ? "è¿‡ç‰Œ" : `è·Ÿæ³¨ (${callAmt})`;
    }

    disableControls(disabled) {
        document.getElementById('btn-fold').disabled = disabled;
        document.getElementById('btn-call').disabled = disabled;
        document.getElementById('btn-raise').disabled = disabled;
    }
}

const game = new PokerGame();
</script>
</body>
</html>