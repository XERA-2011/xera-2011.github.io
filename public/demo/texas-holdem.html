<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¾·å·æ‰‘å…‹ (è¯¦ç»†è®°å½•ç‰ˆ)</title>
    <style>
        :root {
            --felt-color: #35654d;
            --highlight-color: #ffd700;
            --card-w: 46px;
            --card-h: 64px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1a1a1a;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        /* é¡¶éƒ¨ç‰Œå‹æç¤ºæ  */
        #hand-ranks-bar {
            width: 100%;
            background: rgba(0,0,0,0.9);
            display: flex; justify-content: center; gap: 4px;
            padding: 4px 0; z-index: 200;
            flex-wrap: wrap;
            border-bottom: 1px solid #444;
        }
        .rank-item { font-size: 10px; color: #777; padding: 2px 5px; border-radius: 3px; background: #222; }
        .rank-active { color: #000; background: var(--highlight-color); font-weight: bold; }

        /* === æ¸¸æˆä¸»å®¹å™¨ === */
        #game-container {
            width: 100%;
            max-width: 800px;
            position: relative;
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }
        
        /* === ç‰Œæ¡Œ === */
        #game-table {
            position: relative;
            width: 95%;
            padding-bottom: 60%;
            background-color: var(--felt-color);
            border: 12px solid #5d4037;
            border-radius: 300px;
            box-shadow: inset 0 0 60px rgba(0,0,0,0.8);
            margin: 0 auto;
        }

        /* === æ—¥å¿—åŒºåŸŸ (æ–°å¢) === */
        #log-area {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 240px;
            height: 120px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #444;
            border-radius: 6px;
            color: #ccc;
            font-family: "Menlo", "Consolas", monospace;
            font-size: 11px;
            padding: 8px;
            overflow-y: auto;
            z-index: 90;
            pointer-events: auto; /* å…è®¸æ»šåŠ¨ */
            backdrop-filter: blur(2px);
        }
        #log-area div { margin-bottom: 2px; line-height: 1.3; }
        .log-phase { color: #ffd700; font-weight: bold; margin-top: 4px; border-top: 1px dashed #555; padding-top: 2px; }
        .log-win { color: #69f0ae; font-weight: bold; }
        .log-action { color: #bbb; }
        .log-card { color: #fff; font-weight: bold; }

        #community-cards {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            display: flex; gap: 5px; z-index: 5;
        }

        #pot-display {
            position: absolute;
            top: 32%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            background: rgba(0,0,0,0.6);
            padding: 4px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 5;
            color: #ffd700; font-weight: bold;
        }

        /* === ç©å®¶ === */
        .player {
            position: absolute;
            width: var(--card-w);
            display: flex; flex-direction: column; align-items: center;
            z-index: 10; transition: all 0.3s;
        }
        .player-info {
            background: rgba(20,20,20,0.85);
            padding: 2px 4px; border-radius: 4px;
            text-align: center; font-size: 10px;
            width: 140%; margin-bottom: 4px;
            border: 1px solid #444;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            position: relative;
        }
        .player-cards { display: flex; justify-content: center; gap: 1px; }

        /* æ¡Œé¢ç«¯åæ ‡ */
        #p0 { bottom: -12%; left: 50%; transform: translateX(-50%); }
        #p1 { bottom: 10%; left: -5%; }
        #p2 { top: 15%; left: -5%; }
        #p3 { top: -12%; left: 30%; }
        #p4 { top: -12%; right: 30%; }
        #p5 { top: 15%; right: -5%; }
        #p6 { bottom: 10%; right: -5%; }

        /* å¡ç‰Œ */
        .card {
            width: var(--card-w); height: var(--card-h);
            background: white; border-radius: 4px;
            color: black; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            font-weight: 900; font-size: 18px; line-height: 1;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
            position: relative;
        }
        .card.red { color: #d32f2f; }
        .card.back {
            background: repeating-linear-gradient(45deg, #303f9f, #303f9f 5px, #283593 5px, #283593 10px);
            border: 2px solid #eee;
        }
        .card.winning-card {
            border: 2px solid #ffd700;
            box-shadow: 0 0 10px gold; z-index: 100;
        }
        .winner-highlight .player-info { 
            border: 1px solid gold; background: rgba(255, 215, 0, 0.3); color: #fff;
        }
        .active-turn .player-info {
            background: #e65100; border-color: #ff9800; transform: scale(1.1); z-index: 50;
        }
        .dealer-btn {
            background: white; color: black; border-radius: 50%;
            width: 16px; height: 16px; font-size: 10px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            position: absolute; top: -6px; right: -6px; z-index: 30;
            border: 1px solid #333; display: none;
        }

        /* === æ§åˆ¶æ  === */
        #controls {
            width: 100%; max-width: 600px;
            padding: 10px; display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px; z-index: 100; box-sizing: border-box;
            margin-bottom: 10px;
        }
        button {
            padding: 12px 0; font-size: 16px; border: none;
            border-radius: 6px; font-weight: bold; color: white;
            box-shadow: 0 3px 0 rgba(0,0,0,0.3); cursor: pointer;
        }
        button:active { transform: translateY(2px); box-shadow: none; }
        .btn-fold { background: #c62828; }
        .btn-check { background: #1565c0; }
        .btn-raise { background: #2e7d32; }
        .btn-next { background: #ef6c00; grid-column: span 3; display: none; margin-top: 5px; }
        button:disabled { background: #444; color: #777; transform: none; box-shadow: none; }

        /* === ç§»åŠ¨ç«¯é€‚é… === */
        @media (max-width: 600px) {
            :root { --card-w: 11vw; --card-h: 15vw; }
            #game-table { width: 90%; padding-bottom: 135%; border-radius: 150px; }
            
            #p3 { top: -6%; left: 50%; transform: translateX(-50%); }
            #p4 { top: 8%; right: 6%; }
            #p2 { top: 8%; left: 6%; }
            #p5 { top: 38%; right: -8%; }
            #p1 { top: 38%; left: -8%; }
            #p6 { bottom: 18%; right: -5%; }
            #p0 { bottom: -8%; z-index: 60; }
            
            #controls {
                position: fixed; bottom: 0; left: 0; right: 0;
                background: rgba(20,20,20,0.95);
                padding-bottom: 20px; margin: 0;
            }
            #game-container { padding-bottom: 80px; }
            
            /* ç§»åŠ¨ç«¯æ—¥å¿—ä½ç½®å¾®è°ƒ */
            #log-area {
                top: 55px; /* é¿å¼€é¡¶éƒ¨Rankæ¡ */
                left: 50%; transform: translateX(-50%);
                width: 90%; height: 80px;
                background: rgba(0,0,0,0.7);
            }
        }
    </style>
</head>
<body>

    <div id="hand-ranks-bar">
        <div id="rank-0" class="rank-item">é«˜ç‰Œ</div>
        <div id="rank-1" class="rank-item">ä¸€å¯¹</div>
        <div id="rank-2" class="rank-item">ä¸¤å¯¹</div>
        <div id="rank-3" class="rank-item">ä¸‰æ¡</div>
        <div id="rank-4" class="rank-item">é¡ºå­</div>
        <div id="rank-5" class="rank-item">åŒèŠ±</div>
        <div id="rank-6" class="rank-item">è‘«èŠ¦</div>
        <div id="rank-7" class="rank-item">å››æ¡</div>
        <div id="rank-8" class="rank-item">åŒèŠ±é¡º</div>
    </div>

    <div id="game-container">
        <div id="log-area">
            <div style="text-align:center; color:#888;">--- æ¸¸æˆè®°å½• ---</div>
        </div>

        <div id="game-table">
            <div id="pot-display">Pot: 0</div>
            <div id="community-cards"></div>
            
            <div id="p0" class="player"><div class="player-info"><div>ä½ </div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
            <div id="p1" class="player"><div class="player-info"><div>P1</div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
            <div id="p2" class="player"><div class="player-info"><div>P2</div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
            <div id="p3" class="player"><div class="player-info"><div>P3</div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
            <div id="p4" class="player"><div class="player-info"><div>P4</div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
            <div id="p5" class="player"><div class="player-info"><div>P5</div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
            <div id="p6" class="player"><div class="player-info"><div>P6</div><div>$<span class="chips">100</span></div><div class="status"></div><div class="dealer-btn">D</div></div><div class="player-cards"></div></div>
        </div>
    </div>

    <div id="controls">
        <button id="btn-fold" class="btn-fold" onclick="game.humanAction('fold')">å¼ƒç‰Œ</button>
        <button id="btn-call" class="btn-check" onclick="game.humanAction('call')">è·Ÿæ³¨/è¿‡ç‰Œ</button>
        <button id="btn-raise" class="btn-raise" onclick="game.humanAction('raise')">åŠ æ³¨ (20)</button>
        <button id="btn-next" class="btn-next" onclick="game.startNextRound()">ä¸‹ä¸€å±€</button>
    </div>

<script>
const SUITS = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];
const RANK_VALUE = {'2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, 'T':10, 'J':11, 'Q':12, 'K':13, 'A':14};

class Card {
    constructor(rank, suit) {
        this.rank = rank;
        this.suit = suit;
        this.value = RANK_VALUE[rank];
    }
    get color() { return (this.suit === 'â™¥' || this.suit === 'â™¦') ? 'red' : 'black'; }
    toString() { return `${this.suit}${this.rank}`; } // æ–¹ä¾¿æ—¥å¿—è®°å½•
}

class Deck {
    constructor() { this.cards = []; this.reset(); }
    reset() {
        this.cards = [];
        for (let s of SUITS) for (let r of RANKS) this.cards.push(new Card(r, s));
        this.shuffle();
    }
    shuffle() {
        for (let i = this.cards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
        }
    }
    deal() { return this.cards.pop(); }
}

const HandRank = {
    HIGH_CARD: 0, PAIR: 1, TWO_PAIR: 2, TRIPS: 3, STRAIGHT: 4, 
    FLUSH: 5, FULL_HOUSE: 6, QUADS: 7, STRAIGHT_FLUSH: 8
};

// === æ ¸å¿ƒé€»è¾‘ï¼šä¿®å¤åçš„èƒœè´Ÿåˆ¤å®š ===
function evaluateHand(cards) {
    let sorted = [...cards].sort((a,b) => b.value - a.value);
    
    let suitCounts = {}, rankCounts = {};
    sorted.forEach(c => {
        suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1;
        rankCounts[c.value] = (rankCounts[c.value] || 0) + 1;
    });

    let flushSuit = Object.keys(suitCounts).find(s => suitCounts[s] >= 5);
    let flushCards = flushSuit ? sorted.filter(c => c.suit === flushSuit) : [];

    const getStraight = (cardList) => {
        let unique = [];
        cardList.forEach(c => { if(!unique.find(u => u.value === c.value)) unique.push(c); });
        if (unique.some(c => c.value === 14)) {
            let aceLow = new Card('A', unique.find(c=>c.value===14).suit);
            aceLow.value = 1;
            unique.push(aceLow);
        }
        for(let i=0; i<=unique.length-5; i++) {
            if(unique[i].value - unique[i+4].value === 4) return unique.slice(i, i+5);
        }
        return null;
    };

    let straightCards = getStraight(sorted);
    let straightFlushCards = flushSuit ? getStraight(flushCards) : null;

    const calcScore = (rankIdx, best5) => {
        let s = rankIdx * 10000000000;
        s += (best5[0].value * 100000000);
        s += (best5[1].value * 1000000);
        s += (best5[2].value * 10000);
        s += (best5[3].value * 100);
        s += (best5[4].value * 1);
        return s;
    };

    if (straightFlushCards) return { rank: HandRank.STRAIGHT_FLUSH, score: calcScore(8, straightFlushCards), winningCards: straightFlushCards };

    let quadsVal = Object.keys(rankCounts).find(r => rankCounts[r] === 4);
    if (quadsVal) {
        quadsVal = parseInt(quadsVal);
        let quads = sorted.filter(c => c.value === quadsVal);
        let kicker = sorted.find(c => c.value !== quadsVal);
        let best5 = [...quads, kicker];
        return { rank: HandRank.QUADS, score: calcScore(7, best5), winningCards: best5 };
    }

    let tripsVals = Object.keys(rankCounts).filter(r => rankCounts[r] === 3).map(Number).sort((a,b)=>b-a);
    let pairVals = Object.keys(rankCounts).filter(r => rankCounts[r] === 2).map(Number).sort((a,b)=>b-a);
    
    if (tripsVals.length > 0) {
        let tVal = tripsVals[0];
        let pVal = -1;
        if (tripsVals.length > 1) pVal = tripsVals[1];
        else if (pairVals.length > 0) pVal = pairVals[0];

        if (pVal !== -1) {
            let tCards = sorted.filter(c => c.value === tVal);
            let pCards = sorted.filter(c => c.value === pVal).slice(0, 2);
            let best5 = [...tCards, ...pCards];
            return { rank: HandRank.FULL_HOUSE, score: calcScore(6, best5), winningCards: best5 };
        }
    }

    if (flushCards.length >= 5) {
        let best5 = flushCards.slice(0, 5);
        return { rank: HandRank.FLUSH, score: calcScore(5, best5), winningCards: best5 };
    }

    if (straightCards) return { rank: HandRank.STRAIGHT, score: calcScore(4, straightCards), winningCards: straightCards };

    if (tripsVals.length > 0) {
        let tVal = tripsVals[0];
        let trips = sorted.filter(c => c.value === tVal);
        let kickers = sorted.filter(c => c.value !== tVal).slice(0, 2);
        let best5 = [...trips, ...kickers];
        return { rank: HandRank.TRIPS, score: calcScore(3, best5), winningCards: best5 };
    }

    if (pairVals.length >= 2) {
        let p1 = pairVals[0], p2 = pairVals[1];
        let pair1 = sorted.filter(c => c.value === p1);
        let pair2 = sorted.filter(c => c.value === p2);
        let kicker = sorted.find(c => c.value !== p1 && c.value !== p2);
        let best5 = [...pair1, ...pair2, kicker];
        return { rank: HandRank.TWO_PAIR, score: calcScore(2, best5), winningCards: best5 };
    }

    if (pairVals.length === 1) {
        let p1 = pairVals[0];
        let pair = sorted.filter(c => c.value === p1);
        let kickers = sorted.filter(c => c.value !== p1).slice(0, 3);
        let best5 = [...pair, ...kickers];
        return { rank: HandRank.PAIR, score: calcScore(1, best5), winningCards: best5 };
    }

    let best5 = sorted.slice(0, 5);
    return { rank: HandRank.HIGH_CARD, score: calcScore(0, best5), winningCards: best5 };
}

class PokerGame {
    constructor() {
        this.players = [];
        for(let i=0; i<7; i++) {
            this.players.push({
                id: i, isHuman: i === 0, chips: 1000, hand: [], 
                status: 'active', currentBet: 0, isEliminated: false
            });
        }
        this.deck = new Deck();
        this.communityCards = [];
        this.pot = 0;
        this.dealerIdx = Math.floor(Math.random() * 7);
        this.highestBet = 0;
        this.stage = 'preflop';
        this.actorsLeft = 0; 
        this.raisesInRound = 0;
        this.logElem = document.getElementById('log-area');
        
        this.disableControls(true);
        this.startNextRound();
    }

    // === æ–°å¢ï¼šå¢å¼ºçš„æ—¥å¿—è®°å½•å‡½æ•° ===
    log(msg, type='normal') {
        let div = document.createElement('div');
        div.innerHTML = msg;
        if (type === 'phase') div.className = 'log-phase';
        if (type === 'win') div.className = 'log-win';
        if (type === 'action') div.className = 'log-action';
        this.logElem.appendChild(div);
        this.logElem.scrollTop = this.logElem.scrollHeight; // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
    }

    formatCards(cards) {
        return cards.map(c => c.toString()).join(' ');
    }

    startNextRound() {
        let activePlayers = this.players.filter(p => !p.isEliminated);
        if (activePlayers.length <= 1) {
            alert(`æ¸¸æˆç»“æŸ! è·èƒœè€…: P${activePlayers[0].id}`);
            return;
        }

        document.querySelectorAll('.rank-item').forEach(el => el.classList.remove('rank-active'));
        document.querySelectorAll('.player').forEach(el => el.classList.remove('winner-highlight'));
        document.querySelectorAll('.card').forEach(el => el.classList.remove('winning-card')); 
        document.getElementById('btn-next').style.display = 'none';
        this.logElem.innerHTML = '<div style="text-align:center; color:#888;">--- æ–°å›åˆå¼€å§‹ ---</div>'; // æ¸…ç©ºä¸Šå±€æ—¥å¿—
        
        this.deck.reset();
        this.communityCards = [];
        this.pot = 0;
        this.stage = 'preflop';
        this.players.forEach(p => {
            if(!p.isEliminated) {
                p.hand = [this.deck.deal(), this.deck.deal()];
                p.status = 'active';
                p.currentBet = 0;
            } else {
                p.status = 'eliminated';
                p.hand = [];
            }
        });

        do { this.dealerIdx = (this.dealerIdx + 1) % 7; } 
        while (this.players[this.dealerIdx].isEliminated);

        let sbIdx = this.getNextActive(this.dealerIdx);
        let bbIdx = this.getNextActive(sbIdx);
        
        this.bet(sbIdx, 5, true); // true è¡¨ç¤ºå¼ºåˆ¶ç›²æ³¨ï¼Œä¸è®°å…¥"action"æ—¥å¿—é¿å…åˆ·å±
        this.bet(bbIdx, 10, true);
        this.highestBet = 10;
        
        this.log(`åº„å®¶ P${this.dealerIdx}, ç›²æ³¨ $5/$10`, 'phase');
        this.updateUI();
        this.prepareBettingRound(this.getNextActive(bbIdx)); 
    }

    prepareBettingRound(startIdx) {
        this.raisesInRound = 0;
        let activeCount = this.players.filter(p => p.status !== 'eliminated' && p.status !== 'folded').length;
        if(activeCount < 2) { this.showdown(); return; }
        this.actorsLeft = activeCount;
        this.currentTurnIdx = startIdx;
        this.processTurn();
    }

    getNextActive(idx) {
        let next = (idx + 1) % 7;
        while(this.players[next].isEliminated || this.players[next].status === 'folded') {
            next = (next + 1) % 7;
        }
        return next;
    }

    bet(playerIdx, amount, isBlind = false) {
        let p = this.players[playerIdx];
        if (amount > p.chips) amount = p.chips;
        p.chips -= amount;
        p.currentBet += amount;
        this.pot += amount;
        if (p.currentBet > this.highestBet) this.highestBet = p.currentBet;
        if (p.chips === 0 && p.status !== 'folded') p.status = 'allin';
        // ç›²æ³¨ä¸åœ¨è¿™é‡Œè®°å½•æ—¥å¿—ï¼Œåœ¨startNextRoundç»Ÿä¸€æç¤º
    }

    async processTurn() {
        let active = this.players.filter(p => p.status !== 'eliminated' && p.status !== 'folded');
        let notAllIn = active.filter(p => p.status !== 'allin');
        
        if (active.length === 1 || (notAllIn.length === 0 && this.isBetsSettled())) {
            this.runRemainingStages();
            return;
        }

        if (this.actorsLeft <= 0 && this.isBetsSettled()) {
            this.nextStage();
            return;
        }

        let p = this.players[this.currentTurnIdx];
        if (p.status === 'allin') {
            this.currentTurnIdx = this.getNextActive(this.currentTurnIdx);
            this.processTurn(); 
            return;
        }

        document.querySelectorAll('.player').forEach(el => el.classList.remove('active-turn'));
        document.getElementById(`p${p.id}`).classList.add('active-turn');
        
        if (p.isHuman) {
            this.updateControls();
        } else {
            this.disableControls(true);
            setTimeout(() => this.aiAction(p), 500); // ç¨å¾®åŠ å¿«AIé€Ÿåº¦
        }
    }

    isBetsSettled() {
        let active = this.players.filter(p => p.status !== 'eliminated' && p.status !== 'folded' && p.status !== 'allin');
        if (active.length === 0) return true;
        let target = this.highestBet;
        return active.every(p => p.currentBet === target);
    }

    nextStage() {
        this.players.forEach(p => p.currentBet = 0);
        this.highestBet = 0;
        
        let newCards = [];
        let stageName = "";

        if (this.stage === 'preflop') {
            this.stage = 'flop';
            newCards = [this.deck.deal(), this.deck.deal(), this.deck.deal()];
            stageName = "ç¿»ç‰Œ";
        } else if (this.stage === 'flop') {
            this.stage = 'turn';
            newCards = [this.deck.deal()];
            stageName = "è½¬ç‰Œ";
        } else if (this.stage === 'turn') {
            this.stage = 'river';
            newCards = [this.deck.deal()];
            stageName = "æ²³ç‰Œ";
        } else if (this.stage === 'river') {
            this.showdown();
            return;
        }

        this.communityCards.push(...newCards);
        this.log(`--- ${stageName}: <span class="log-card">[${this.formatCards(newCards)}]</span> ---`, 'phase');
        this.updateUI();
        let startIdx = this.getNextActive(this.dealerIdx);
        this.prepareBettingRound(startIdx);
    }

    runRemainingStages() {
        while(this.stage !== 'showdown') {
             if (this.stage === 'river') { this.showdown(); return; }
             this.nextStage();
        }
    }

    showdown() {
        this.stage = 'showdown';
        document.querySelectorAll('.player').forEach(el => el.classList.remove('active-turn'));
        this.updateUI(); 

        let active = this.players.filter(p => p.status !== 'folded' && p.status !== 'eliminated');
        let bestScore = -1;
        let winners = [];

        this.log('>>> æ‘Šç‰Œå†³èƒœ <<<', 'phase');

        // è®¡ç®—å¹¶æ˜¾ç¤ºæ‰€æœ‰äººçš„ç‰Œå‹
        let results = active.map(p => {
            let fullHand = [...p.hand, ...this.communityCards];
            let res = evaluateHand(fullHand);
            this.renderCards(p.id, p.hand, true);
            // è®°å½•æ¯ä¸ªäººçš„æ‰‹ç‰Œç»“æœ
            // this.log(`P${p.id}: ${this.getRankName(res.rank)} (${this.formatCards(res.winningCards)})`, 'action');
            return { player: p, result: res };
        });

        results.forEach(r => {
            if (r.result.score > bestScore) bestScore = r.result.score;
        });

        winners = results.filter(r => r.result.score === bestScore);
        let winAmount = Math.floor(this.pot / winners.length);

        winners.forEach(w => {
            let p = w.player;
            p.chips += winAmount;
            
            document.getElementById(`p${p.id}`).classList.add('winner-highlight');
            let rankEl = document.getElementById(`rank-${w.result.rank}`);
            if(rankEl) rankEl.classList.add('rank-active');
            
            this.highlightWinningCards(p.id, w.result.winningCards);
            
            // === è¯¦ç»†çš„è·èƒœæ—¥å¿— ===
            let rankName = this.getRankName(w.result.rank);
            let winCardsStr = this.formatCards(w.result.winningCards);
            this.log(`ğŸ† P${p.id} èµ¢äº† $${winAmount}!`, 'win');
            this.log(`&nbsp;&nbsp;ç‰Œå‹: ${rankName}`, 'win');
            this.log(`&nbsp;&nbsp;æœ€ä½³äº”å¼ : ${winCardsStr}`, 'win');
        });

        this.players.forEach(p => {
            if (p.chips <= 0) {
                p.chips = 0; p.isEliminated = true; p.status = 'eliminated';
            }
        });

        this.pot = 0;
        document.getElementById('pot-display').textContent = `Pot: 0`;
        this.players.forEach(p => document.querySelector(`#p${p.id} .chips`).textContent = p.chips);
        document.getElementById('btn-next').style.display = 'block';
        this.disableControls(true);
    }

    highlightWinningCards(winnerId, winningCards) {
        let p = this.players[winnerId];
        let pCardsHtml = p.hand.map(c => {
            let isWin = winningCards.some(wc => wc.rank === c.rank && wc.suit === c.suit);
            return this.createCardHtml(c, isWin);
        }).join('');
        document.querySelector(`#p${winnerId} .player-cards`).innerHTML = pCardsHtml;

        let commHtml = this.communityCards.map(c => {
             let isWin = winningCards.some(wc => wc.rank === c.rank && wc.suit === c.suit);
             return this.createCardHtml(c, isWin);
        }).join('');
        document.getElementById('community-cards').innerHTML = commHtml;
    }
    
    getRankName(idx) {
        const names = ["é«˜ç‰Œ", "ä¸€å¯¹", "ä¸¤å¯¹", "ä¸‰æ¡", "é¡ºå­", "åŒèŠ±", "è‘«èŠ¦", "å››æ¡", "åŒèŠ±é¡º"];
        return names[idx];
    }

    handleAction(player, action, amount=0) {
        let callAmt = this.highestBet - player.currentBet;
        let actionStr = "";
        
        if (action === 'fold') {
            player.status = 'folded';
            actionStr = "å¼ƒç‰Œ";
        } else if (action === 'call') {
            this.bet(player.id, callAmt);
            actionStr = callAmt === 0 ? "è¿‡ç‰Œ" : `è·Ÿæ³¨ $${callAmt}`;
        } else if (action === 'raise') {
            let raiseAmt = callAmt + amount;
            this.bet(player.id, raiseAmt);
            this.raisesInRound++;
            actionStr = `åŠ æ³¨ åˆ° $${player.currentBet}`; // æ˜¾ç¤ºå½“å‰æ€»ä¸‹æ³¨é¢æ›´ç›´è§‚
            let activeNotAllIn = this.players.filter(p => 
                p.status !== 'folded' && p.status !== 'eliminated' && p.status !== 'allin'
            ).length;
            this.actorsLeft = activeNotAllIn; 
        }

        // è®°å½•æ—¥å¿—
        let name = player.isHuman ? "ä½ " : `P${player.id}`;
        this.log(`${name}: ${actionStr}`, 'action');

        this.actorsLeft--;
        this.updateUI();
        this.currentTurnIdx = this.getNextActive(this.currentTurnIdx);
        this.processTurn();
    }

    humanAction(type) {
        let p = this.players[0];
        if (type === 'raise') this.handleAction(p, 'raise', 20);
        else this.handleAction(p, type);
    }

    aiAction(player) {
        let callAmt = this.highestBet - player.currentBet;
        let fullHand = [...player.hand, ...this.communityCards];
        let action = 'fold';
        let strength = 0; 
        
        if (fullHand.length < 5) {
            let v1 = player.hand[0].value, v2 = player.hand[1].value;
            if (v1 === v2) strength = 0.8; 
            else if (v1 > 10 && v2 > 10) strength = 0.6; 
            else if (v1 > 12 || v2 > 12) strength = 0.4; 
        } else {
            let res = evaluateHand(fullHand);
            strength = (res.rank + (res.score % 10000000000) / 10000000000) / 9; 
            if (res.rank >= 2) strength = 0.8;
            else if (res.rank === 1) strength = 0.5;
            else strength = 0.2;
        }

        let rnd = Math.random();
        if (strength > 0.7) {
            if (rnd > 0.3) action = 'raise'; else action = 'call';
        } else if (strength > 0.4) {
            if (callAmt < 50) action = 'call'; else action = (rnd > 0.6 ? 'call' : 'fold');
        } else {
            if (callAmt === 0) action = 'call'; else action = (rnd > 0.8 ? 'call' : 'fold');
        }

        if (action === 'raise' && this.raisesInRound >= 3) action = 'call';
        if (action === 'raise' && player.chips <= callAmt + 20) action = 'call';

        if (action === 'raise') this.handleAction(player, 'raise', 20);
        else this.handleAction(player, action);
    }

    updateUI() {
        document.getElementById('pot-display').textContent = `Pot: ${this.pot}`;
        document.getElementById('community-cards').innerHTML = this.communityCards.map(c => this.createCardHtml(c)).join('');

        this.players.forEach(p => {
            let el = document.getElementById(`p${p.id}`);
            el.querySelector('.chips').textContent = p.chips;
            
            let statusText = '';
            if (p.status === 'folded') statusText = 'Fold';
            else if (p.status === 'eliminated') statusText = 'Out';
            else if (p.status === 'allin') statusText = 'All-in';
            else if (p.currentBet > 0) statusText = `$${p.currentBet}`;
            
            el.querySelector('.status').textContent = statusText;
            el.querySelector('.dealer-btn').style.display = (this.dealerIdx === p.id) ? 'flex' : 'none';

            if (p.hand.length > 0) {
                let showFace = (p.isHuman || this.stage === 'showdown');
                this.renderCards(p.id, p.hand, showFace);
            } else {
                el.querySelector('.player-cards').innerHTML = '';
            }
            
            if (p.status === 'folded') el.querySelector('.player-cards').classList.add('folded');
            else el.querySelector('.player-cards').classList.remove('folded');
            if (p.isEliminated) el.style.opacity = 0.4;
        });
    }

    renderCards(pid, cards, showFace) {
        let html = '';
        if (showFace) html = cards.map(c => this.createCardHtml(c)).join('');
        else html = `<div class="card back"></div><div class="card back"></div>`;
        document.getElementById(`p${pid}`).querySelector('.player-cards').innerHTML = html;
    }

    createCardHtml(card, isHighlighted = false) {
        let cls = `card ${card.color} ${isHighlighted ? 'winning-card' : ''}`;
        return `<div class="${cls}">${card.suit}<br>${card.rank}</div>`;
    }

    updateControls() {
        let p = this.players[0];
        let callAmt = this.highestBet - p.currentBet;
        document.getElementById('btn-fold').disabled = false;
        document.getElementById('btn-call').disabled = false;
        document.getElementById('btn-raise').disabled = (p.chips <= callAmt) || (this.raisesInRound >= 4);
        document.getElementById('btn-call').textContent = (callAmt === 0) ? "è¿‡ç‰Œ" : `è·Ÿæ³¨ (${callAmt})`;
    }

    disableControls(disabled) {
        document.getElementById('btn-fold').disabled = disabled;
        document.getElementById('btn-call').disabled = disabled;
        document.getElementById('btn-raise').disabled = disabled;
    }
}

const game = new PokerGame();
</script>
</body>
</html>